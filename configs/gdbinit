# Add in ~/.gdbinit
# python from os import path
# python dotfilespath = path.join(path.expanduser("~"), "sources/dotfiles/configs/gdbinit")
# python if path.exists(dotfilespath): gdb.execute('source {}'.format(dotfilespath))

# python
# import sys
# # python sys.path.append("/usr/share/gcc-8/python");
# from libstdcxx.v6.printers import register_libstdcxx_printers
# register_libstdcxx_printers (None)
# end
set auto-load python-scripts on
set auto-solib-add on
set print pretty on
set print array on
set print array-indexes on
set print elements 500
set breakpoint pending on
# below is due to crash
set print raw-frame-arguments
unset environment PYTHONHOME
add-auto-load-safe-path /home/linuxbrew/.linuxbrew/Cellar/gcc/15.2.0/lib/gcc/current/libstdc++.so.6.0.34-gdb.py

set $hwprettyprint=1

define pattach
  if $argc != 1
   help pattach
  else
   shell echo -e "\
set \$PID = "$(pgrep -n $arg0)"\n\
if \$PID > 0\n\
  attach "$(pgrep -n $arg0)"\n\
else\n\
  print \"Process '"$arg0"' not found\"\n\
end" > /tmp/gdb.pgrep
   source /tmp/gdb.pgrep
  end
end
document pattach
Attach to process by name.
Usage: pattach PROG_NAME
end

define rrattach
    if $argc > 0
      file ~/.local/share/rr/latest-trace/mmap_clone_3_$arg0
    else
        file ../common/framework/linux64/hwx/bin/linux64/hwx
    end
    set sysroot /
    target extended-remote 127.0.0.1:5000
end
document rrattach
Attach to latest rr recording
Use after : rr replay -s 5000
end

define ldsyms
   sharedlibrary libcommands.so
   sharedlibrary libafcmesh.so
   sharedlibrary libhmobj.so
   sharedlibrary libhmcore.so
end
document ldsyms
    load common shared library symbols
end

python
import sys
sys.path.append("/usr/share/gcc/python")
from libstdcxx.v6.printers import register_libstdcxx_printers
register_libstdcxx_printers(None)

class IgnoreErrors(gdb.Command):
    """Run a GDB command and ignore errors."""

    def __init__(self):
        super(IgnoreErrors, self).__init__("ignore-errors", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        try:
            gdb.execute(arg)
        except gdb.error:
            pass

class SourceIfExists(gdb.Command):
    """Run a GDB command and ignore errors."""

    def __init__(self):
        super(SourceIfExists, self).__init__("sourceifexists", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        filetosource = path.expanduser(arg)
        if path.exists(filetosource): 
            gdb.execute("source {}".format(filetosource))
            print("[Sourced] {}.".format(filetosource))
        else:
            print("[Skipped] {} does not exist.".format(filetosource))


class SearchAndSource(gdb.Command):
    """Search for a file in common locations and source it if found."""

    def __init__(self):
        super(SearchAndSource, self).__init__("searchandsource", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        locationstosearch = [
            "/mnt/work/repos/CommonUtils/linux_scripts/{}".format(arg),
            "/work/repos/CommonUtils/linux_scripts/{}".format(arg),
            "/workarea/CommonUtils/linux_scripts/{}".format(arg),
            path.expanduser("~/CommonUtils/linux_scripts/{}".format(arg)),
            "./{}".format(arg)
        ]
        for loc in locationstosearch:
            if path.exists(loc):
                gdb.execute("source {}".format(loc))
                print("[Sourced] {}.".format(loc))
                return

IgnoreErrors()
SourceIfExists()
SearchAndSource()

end

searchandsource gdbCustomCommands.py
searchandsource hmpretprinters.py
sourceifexists ~/sources/eigengdb/eigengdb/__init__.py
sourceifexists .gdbinit
